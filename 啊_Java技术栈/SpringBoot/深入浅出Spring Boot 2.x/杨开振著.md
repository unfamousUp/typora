# 深入浅出Spring Boot

"约定优于配置"

## 一、Spring Boot来临

### 1.1 Spring的历史

#### - 降低资源耦合

 Spring以强大的控制反转（IOC）来管理各类Java资源，从而==降低了各种资源的耦合==。

> - 降低了各种资源的耦合
>
>   - Java中的资源耦合指的是在代码中资源（如文件、数据库连接、网络连接等）与应用程序的其他部分之间存在紧密的关联关系，`资源的管理和使用与应用逻辑混合在一起`，难以分离和管理。资源耦合通是一种不良的设计实践，因为它会导致代码难以维护、扩展和重用
>
>   - 资源耦合的问题在于，如果不正确管理资源的生命周期，可能会导致资源泄漏或不必要的资源开销，从而影响应用程序的性能和可维护性。通过将资源的管理与应用逻辑分离，可以减少这些问题的发生。

- 一个常见的【数据库连接】的耦合问题：是在代码中直接使用了具体的数据库驱动程序和连接参数，这样会导致代码与特定数据库的耦合，不利于代码的移植和维护。下面是一个简单的示例：

  ```java
  public class DatabaseConnection {
      private static Connection connection;
  
      public static Connection getConnection() {
          if (connection == null) {
              try {
                  Class.forName("com.mysql.jdbc.Driver");
                  connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
              } catch (ClassNotFoundException | SQLException e) {
                  e.printStackTrace();
              }
          }
          return connection;
      }
  }
  ```

  在这个示例中，`DatabaseConnection` 类直接使用了 MySQL 的驱动程序和连接参数，导致了与 MySQL 数据库的耦合。如果要切换到其他数据库，比如 Oracle 或者 PostgreSQL，就需要修改 `DatabaseConnection` 类的代码。

- 解决这个问题的常见方案是使用数据访问层（DAO）模式和配置文件。我们可以定义一个接口来表示数据库连接，然后在配置文件中指定具体的实现类和连接参数。这样，只需要修改配置文件而不需要修改代码就可以切换数据库。下面是一个简单的示例：

  1. 首先，定义一个数据库连接的接口：

  ```java
  public interface DatabaseConnection {
      Connection getConnection();
  }
  ```

  2. 然后，创建两个实现类分别用于连接 MySQL 和 PostgreSQL：

  ```java
  // MySQL连接
  public class MySQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("com.mysql.jdbc.Driver");
              return DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  // PostgreSQL连接
  public class PostgreSQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("org.postgresql.Driver");
              return DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  ```

  3. 最后，在配置文件中指定使用哪个实现类：

  ```java
  <bean id="databaseConnection" class="com.example.MySQLConnection" />
  ```

### 1.2 注解还是XML

- 业务类使用注解，例如MVC开发：控制器使用`@Controller`，业务层使用`service`，持久层使用`@Repository`。
- 对于一些公用的Bean，例如对于数据库（如Redis）、第三方资源等则使用XML进行配置

###  1.3 Spring Boot的优点

- 创建独立的Spring程序

- 嵌入的Tomcat、无需部署WAR文件

- 允许通过Maven来根据需要获取starter

- 尽可能地自动配置Spring

  ....

### 1.4 传统SpringMVC和Spring Boot的对比

#### - Servlet

- Servlet执行流程

  ![image-20220621234937489](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121641694.png)

- Servlet生命周期

  ![image-20220622000339816](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655319.png)

- Servlet体系结构

  ![image-20220622002157646](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655200.png)

#### - SpringMVC项目具体流程

##### - xml方式

- 创建空项目-添加maven工程-导入web模块-导入相关依赖

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>com.cjj</groupId>
      <artifactId>springmvc_note</artifactId>
      <version>1.0-SNAPSHOT</version>
      <packaging>war</packaging>
  
      <dependencies>
          <!-- SpringMVC -->
          <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-webmvc</artifactId>
              <version>5.3.1</version>
          </dependency>
          <!-- ServletAPI -->
          <dependency>
              <groupId>javax.servlet</groupId>
              <artifactId>javax.servlet-api</artifactId>
              <version>3.1.0</version>
              <scope>provided</scope>
          </dependency>
          <!-- Spring5和Thymeleaf整合包 -->
          <dependency>
              <groupId>org.thymeleaf</groupId>
              <artifactId>thymeleaf-spring5</artifactId>
              <version>3.0.12.RELEASE</version>
          </dependency>
      </dependencies>
  
  </project>
  
  ```

- 配置web.xml和springmvc.xml

  - 创建web.xml文件

    - `web.xml` 是一个【部署描述符文件】（Deployment Descriptor），用于配置 Servlet 容器（如 Tomcat）在部署和运行应用程序时的行为。`web.xml` 文件中包含了一些重要的配置，如 Servlet、Filter、Listener 等的配置，以及一些全局的配置。

    - 在 Servlet 容器启动时，会由容器来读取并解析 `web.xml` 文件，加载配置的 Servlet、Filter、Listener 等，并按照配置来初始化和处理请求。在 Spring MVC 中，`DispatcherServlet` 会由 Servlet 容器（比如 Tomcat）来创建和管理。

    - `web.xml` 文件由 Servlet 容器（例如 Tomcat、Jetty、JBoss 等）读取和解析。Servlet 容器在启动时会加载部署在其中的 Web 应用程序，并根据 `web.xml` 中的配置初始化 Servlet、Filter、Listener 等，并建立 URL 映射关系，以便处理客户端的请求。

      一旦 Servlet 容器启动并加载了 Web 应用程序，它会负责管理整个应用程序的生命周期，包括请求的路由、Servlet 的生命周期管理、会话管理等。因此，`web.xml` 文件对于 Servlet 容器来说是非常重要的配置文件之一。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
        <servlet>
            <!-- 
                <servlet-name> 标签用于定义一个 Servlet 的名称，该名称在 Servlet 容器中必须是唯一的。
                它通常用于配合其他标签，如 <servlet> 和 <servlet-mapping>，来指定一个 Servlet的配置和映			  射关系。 
             -->
            <servlet-name>springMVC</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
            <init-param>
                <!-- contextConfigLocation为固定值,指定 Spring 应用程序上下文配置文件位置的参数 -->
                <param-name>contextConfigLocation</param-name>
                <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的
                src/main/resources -->
                <param-value>/web/WEB-INF/springMVC.xml</param-value>
            </init-param>
            <!--
            作为框架的核心组件，在启动过程中有大量的初始化操作要做
            而这些操作放在第一次请求时才执行会严重影响访问速度
            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
            -->
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>springMVC</servlet-name>
            <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
            -->
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - 创建springmvc.xml文件

    > - 不用手动加载配置文件，在DispatcherServlet初始化的时候就会自动加载SpringMVC的配置文件
    > - 所以SpringMCV配置文件有一个固定的名字和一个固定的位置
    >   - 默认位置：WEB-INF包下
    >   - 默认名称：`<servlet-name>`的值加上`-servlet.xml`，也就是`SpringMVC-servlet.xml`

    - 在 Spring MVC 中，`springmvc.xml`（或其他类似的命名）通常是用来配置 Spring MVC 相关的内容的配置文件，比如【视图解析器】、【拦截器】、【处理器映射】等。它一般放在 `WEB-INF` 目录下，与 `web.xml` 放在同一个目录下或者放在 `WEB-INF/config` 目录下都是比较常见的做法。
    - 通常情况下，`springmvc.xml` 文件的位置会在 `web.xml` 中通过 `<context-param>` 标签来指定

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    
        <!--扫描组件-->
        <context:component-scan base-package="com.cjj.controller"></context:component-scan>
    
        <!-- 配置Thymeleaf视图解析器 -->
        <!--可以使用SpringMVC为我们提供的方式，来进行视图渲染，并实现页面跳转-->
        <!--通过源码：由SpringMVC中DispatcherServlet内部帮我们加载的-->
        <bean id="viewResolver"
              class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
            <!--优先级-->
            <property name="order" value="1"/>
            <!--编码-->
            <property name="characterEncoding" value="UTF-8"/>
            <!--模板引擎-->
            <property name="templateEngine">
                <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                    <!--模板解析器-->
                    <property name="templateResolver">
                        <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
                            <!-- 视图前缀 -->
                            <property name="prefix" value="/WEB-INF/templates/"/>
                            <!-- 视图后缀 -->
                            <property name="suffix" value=".html"/>
                            <property name="templateMode" value="HTML5"/>
                            <property name="characterEncoding" value="UTF-8" />
                        </bean>
                    </property>
                </bean>
            </property>
        </bean>
    </beans>
    ```

- 创建请求控制器

  > 我们SpringMVC封装的是Servlet，我们不需要手动创建servlet，当前所有的请求经过web.xml的配置都被我们的DispatcherServlet来处理了。它处理的是共性的问题：获取请求参数，往域对象中共享数据，页面跳转，转发和重定向。当前请求具体如何处理则需要写一个方法。

  由于`前端控制器`对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即`请求控制器`

  请求控制器中每一个处理请求的方法成为控制器方法

  因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在

  ```java
  // 当前控制层中的方法，可以通过SpringMVC为我们提供的方式将它设置为处理请求的方法
  @Controller
  public class HelloController {
      
  }
  ```

##### - 注解方式

- 创建初始化类`【WebInit】`，代替web.xml

  > - Servlet容器：Tomcat
  >
  > - 在Servlet3.0环境中，容器会在类路径中查找实现`javax.servlet.ServletContainerInitializer`接口的实现类，如果找到的话就用它来配置Servlet容器。
  >
  >   Spring提供了这个接口的实现，名为`SpringServletContainerInitializer`，这个类反过来又会查找实现`WebApplicationInitializer`的类并将配置的任务交给它们来完成。
  >
  >   Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为`AbstractAnnotationConfigDispatcherServletInitializer`，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。

  ```java
  package com.cjj.config;
  import org.springframework.web.filter.CharacterEncodingFilter;
  import org.springframework.web.filter.HiddenHttpMethodFilter;
  import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
  
  import javax.servlet.Filter;
  //【WebInit】
  // web.xml
  // WebInit拓展了Spring实现的Servlet容器初始化器，这样我们自定义的类就可以被Tomcat容器找到了
  public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {
  	
      // 配置1
      @Override
      protected Class<?>[] getRootConfigClasses() {
          return new Class[]{SpringConfig.class};
      }
  
      // SpringMVC配置类
      @Override
      protected Class<?>[] getServletConfigClasses() {
          return new Class[]{WebConfig.class};
      }
  	
      // 设置DispatcherServlet 的映射路径
      @Override
      protected String[] getServletMappings() {
          return new String[]{"/"};
      }
  
      @Override
      // 设置当前的过滤器
      protected Filter[] getServletFilters() {
          // 创建编码过滤器
          CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
          // 设置请求和响应的编码
          characterEncodingFilter.setEncoding("UTF-8");
          characterEncodingFilter.setForceEncoding(true);
          // 创建请求方式的过滤器
          HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
          return new Filter[]{characterEncodingFilter,hiddenHttpMethodFilter};
      }
  }
  ```

- 创建WebConfig配置类，代替SpringMVC的配置文件

  > SpringMVC配置过的内容
  >
  > 1. 扫描控制层组件
  > 2. 视图解析器
  > 3. view-controller默认的servlet处理静态资源
  > 4. 开启mvc注解驱动
  > 5. 文件上传解析器
  > 6. 拦截器
  > 7. 异常解析器

```java
/**
 * 代替SpringMVC的配置文件
 */
// 将类表示为配置类
@Configuration
// 扫描组件
@ComponentScan("com.cjj.controller")
// 开启MVC注解驱动
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    // 默认的servlet处理静态资源
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
        WebMvcConfigurer.super.configureDefaultServletHandling(configurer);
    }

    @Override
    // 配置视图解析器
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
        WebMvcConfigurer.super.addViewControllers(registry);
    }

    @Bean
    // 文件上传解析器：被Bean标识的方法的返回值将会作为bean被IOC容器所管理,bean的id为方法名
    public CommonsMultipartResolver multipartResolver() {
        return new CommonsMultipartResolver();
    }

    @Override
    // 配置拦截器
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");
        WebMvcConfigurer.super.addInterceptors(registry);
    }

    @Override
    // 异常处理器
    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
        properties.setProperty("java.lang.ArithmeticException", "error");
        exceptionResolver.setExceptionMappings(properties);
        exceptionResolver.setExceptionAttribute("ex");
        resolvers.add(exceptionResolver);
        WebMvcConfigurer.super.configureHandlerExceptionResolvers(resolvers);
    }

    //配置生成模板解析器
    @Bean
    public ITemplateResolver templateResolver() {
        WebApplicationContext webApplicationContext =
                ContextLoader.getCurrentWebApplicationContext();
        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，
        // 可通过WebApplicationContext的方法获得
        ServletContextTemplateResolver templateResolver =
                new ServletContextTemplateResolver(webApplicationContext.getServletContext());
        templateResolver.setPrefix("/WEB-INF/templates/");
        templateResolver.setSuffix(".html");
        templateResolver.setCharacterEncoding("UTF-8");
        templateResolver.setTemplateMode(TemplateMode.HTML);
        return templateResolver;
    }

    //生成模板引擎并为模板引擎注入模板解析器
    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
    }

    //生成视图解析器并为解析器注入模板引擎
    @Bean
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setCharacterEncoding("UTF-8");
        viewResolver.setTemplateEngine(templateEngine);
        return viewResolver;
    }

}
```

- 拦截器的配置

```java
@Component
public class FirstInterceptor implements HandlerInterceptor {
    /**
     * 控制器方法执行之前执行
     * @param request
     * @param response
     * @param handler
     * @return false:拦截|true:放行
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("FirstInterceptor-->preHandle");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("FirstInterceptor-->postHandle");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("FirstInterceptor-->afterCompletion");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

```java
// springMVC.xml
@Configuration
@EnableWebMvc
@ComponentScan("com.cjj.controller")
public class WebConfig implements WebMvcConfigurer {

    @Override
    // 配置拦截器
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");
        WebMvcConfigurer.super.addInterceptors(registry);
    }
    
}
```

## 二、开发环境（略）

## 三、全注解下的Spring IOC

IOC是一种通过`描述`来生成或者获取对象的技术。

> - Spring Bean（Bean）：在Spring中需要管理的每一个对象
> - Spring IOC容器（IOC 容器）：由Spring管理这些Bean的容器
>   - 通过描述管理Bean，包括发布和获取Bean
>   - 通过描述来完成Bean之间的依赖关系

### 3.1 IOC容器简介

#### 3.1.1 BeanFactory

所有IOC容器都需要实现接口`BeanFactory`，它是一个顶级容器接口。

> 注意：
>
> - IOC容器中，默认Bean都是以单例存在的，也就是使用`getBean`方法返回的都是同一个对象！反之，如果`isPrototype`方法返回的是`true`，那使用`getBean`方法获取bean时，IOC容器就会创建一个新的Bean给调用者。
>
> - 由于BeanFactory功能还不够强大，于是设计了一个更高级的子接口`ApplicationContext`。
>
>   ![image-20240313163418400](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403131634567.png)

```java
public interface BeanFactory {
    String FACTORY_BEAN_PREFIX = "&";

    // 多个getBean方法
    Object getBean(String var1) throws BeansException;

    <T> T getBean(String var1, Class<T> var2) throws BeansException;

    Object getBean(String var1, Object... var2) throws BeansException;

    <T> T getBean(Class<T> var1) throws BeansException;

    <T> T getBean(Class<T> var1, Object... var2) throws BeansException;

    <T> ObjectProvider<T> getBeanProvider(Class<T> var1);

    <T> ObjectProvider<T> getBeanProvider(ResolvableType var1);

    // 是否包含Bean
    boolean containsBean(String var1);

    // Bean是否是单例
    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;

    // Bean是否是原型
    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;

    // Bean是否类型匹配
    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, Class<?> var2) throws NoSuchBeanDefinitionException;

    // 获取Bean的类型
    @Nullable
    Class<?> getType(String var1) throws NoSuchBeanDefinitionException;

    @Nullable
    Class<?> getType(String var1, boolean var2) throws NoSuchBeanDefinitionException;

    // 获取Bean的别名
    String[] getAliases(String var1);
}
```

#### 3.1.2 代码实现

> 定义一个java配置文件AppConfig
>
> - Spring 管理的 IOC 容器
>   - `SpringApplication.run(MyApplication.class, args)` 方法会创建一个 IOC 容器，并扫描应用程序中的所有 `@Component`、`@Service`、`@Repository` 和 `@Controller` 注解标记的类，并将它们注册为 bean。这个 IOC 容器就是 Spring 管理的 IOC 容器，负责管理整个应用程序的 bean。
>
> - 手动创建的IOC容器
>
>   ```java
>       // 创建一个新的IOC容器，并将AppConfig本身作为bean以及AppConfig 类中定义的 bean 注册到了这个容器中。
>       ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);
>   ```

```java
@Configuration
public class AppConfig {
    @Bean("user")
    public User initUser(){
        User user = new User();
        user.setAge(19);
        user.setName("cjj");
        return user;
    }
}
```

> IOCTest测试方法

```java
@Test
void IOCTest(){
    // 创建一个新的IOC容器，并将AppConfig本身作为bean以及AppConfig 类中定义的 bean 注册到了这个容器中。
    ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);
    User user = ioc.getBean(User.class);
    System.out.println(user);
}
```

### 3.2 装配你的Bean

#### 3.2.1 通过扫描装配你的Bean

如果使用`@Bean`注解一个个把Bean注入到IOC容器中，很麻烦。可以使用`@Component`和@`ComponentScan`注解。