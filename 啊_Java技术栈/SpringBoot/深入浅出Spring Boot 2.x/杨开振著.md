# 深入浅出Spring Boot

"约定优于配置"

## 一、Spring Boot来临

### 1.1 Spring的历史

#### - 降低资源耦合

 Spring以强大的控制反转（IOC）来管理各类Java资源，从而==降低了各种资源的耦合==。

> - 降低了各种资源的耦合
>
>   - Java中的资源耦合指的是在代码中资源（如文件、数据库连接、网络连接等）与应用程序的其他部分之间存在紧密的关联关系，`资源的管理和使用与应用逻辑混合在一起`，难以分离和管理。资源耦合通是一种不良的设计实践，因为它会导致代码难以维护、扩展和重用
>
>   - 资源耦合的问题在于，如果不正确管理资源的生命周期，可能会导致资源泄漏或不必要的资源开销，从而影响应用程序的性能和可维护性。通过将资源的管理与应用逻辑分离，可以减少这些问题的发生。

- 一个常见的【数据库连接】的耦合问题：是在代码中直接使用了具体的数据库驱动程序和连接参数，这样会导致代码与特定数据库的耦合，不利于代码的移植和维护。下面是一个简单的示例：

  ```java
  public class DatabaseConnection {
      private static Connection connection;
  
      public static Connection getConnection() {
          if (connection == null) {
              try {
                  Class.forName("com.mysql.jdbc.Driver");
                  connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
              } catch (ClassNotFoundException | SQLException e) {
                  e.printStackTrace();
              }
          }
          return connection;
      }
  }
  ```

  在这个示例中，`DatabaseConnection` 类直接使用了 MySQL 的驱动程序和连接参数，导致了与 MySQL 数据库的耦合。如果要切换到其他数据库，比如 Oracle 或者 PostgreSQL，就需要修改 `DatabaseConnection` 类的代码。

- 解决这个问题的常见方案是使用数据访问层（DAO）模式和配置文件。我们可以定义一个接口来表示数据库连接，然后在配置文件中指定具体的实现类和连接参数。这样，只需要修改配置文件而不需要修改代码就可以切换数据库。下面是一个简单的示例：

  1. 首先，定义一个数据库连接的接口：

  ```java
  public interface DatabaseConnection {
      Connection getConnection();
  }
  ```

  2. 然后，创建两个实现类分别用于连接 MySQL 和 PostgreSQL：

  ```java
  // MySQL连接
  public class MySQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("com.mysql.jdbc.Driver");
              return DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  // PostgreSQL连接
  public class PostgreSQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("org.postgresql.Driver");
              return DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  ```

  3. 最后，在配置文件中指定使用哪个实现类：

  ```java
  <bean id="databaseConnection" class="com.example.MySQLConnection" />
  ```

### 1.2 注解还是XML

- 业务类使用注解，例如MVC开发：控制器使用`@Controller`，业务层使用`service`，持久层使用`@Repository`。
- 对于一些公用的Bean，例如对于数据库（如Redis）、第三方资源等则使用XML进行配置

###  1.3 Spring Boot的优点

- 创建独立的Spring程序

- 嵌入的Tomcat、无需部署WAR文件

- 允许通过Maven来根据需要获取starter

- 尽可能地自动配置Spring

  ....

### 1.4 传统SpringMVC和Spring Boot的对比

#### - Servlet

- Servlet执行流程

  ![image-20220621234937489](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121641694.png)

- Servlet生命周期

  ![image-20220622000339816](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655319.png)

- Servlet体系结构

  ![image-20220622002157646](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655200.png)

#### - SpringMVC项目具体流程

- 创建空项目-添加maven工程-导入web模块-导入相关依赖

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>com.cjj</groupId>
      <artifactId>springmvc_note</artifactId>
      <version>1.0-SNAPSHOT</version>
      <packaging>war</packaging>
  
      <dependencies>
          <!-- SpringMVC -->
          <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-webmvc</artifactId>
              <version>5.3.1</version>
          </dependency>
          <!-- ServletAPI -->
          <dependency>
              <groupId>javax.servlet</groupId>
              <artifactId>javax.servlet-api</artifactId>
              <version>3.1.0</version>
              <scope>provided</scope>
          </dependency>
          <!-- Spring5和Thymeleaf整合包 -->
          <dependency>
              <groupId>org.thymeleaf</groupId>
              <artifactId>thymeleaf-spring5</artifactId>
              <version>3.0.12.RELEASE</version>
          </dependency>
      </dependencies>
  
  </project>
  
  ```

- 配置web.xml和springmvc.xml

  - 创建web.xml文件

    - `web.xml` 是一个【部署描述符文件】（Deployment Descriptor），用于配置 Servlet 容器（如 Tomcat）在部署和运行应用程序时的行为。`web.xml` 文件中包含了一些重要的配置，如 Servlet、Filter、Listener 等的配置，以及一些全局的配置。

    - 在 Servlet 容器启动时，会由容器来读取并解析 `web.xml` 文件，加载配置的 Servlet、Filter、Listener 等，并按照配置来初始化和处理请求。在 Spring MVC 中，`DispatcherServlet` 会由 Servlet 容器（比如 Tomcat）来创建和管理。

    - `web.xml` 文件由 Servlet 容器（例如 Tomcat、Jetty、JBoss 等）读取和解析。Servlet 容器在启动时会加载部署在其中的 Web 应用程序，并根据 `web.xml` 中的配置初始化 Servlet、Filter、Listener 等，并建立 URL 映射关系，以便处理客户端的请求。

      一旦 Servlet 容器启动并加载了 Web 应用程序，它会负责管理整个应用程序的生命周期，包括请求的路由、Servlet 的生命周期管理、会话管理等。因此，`web.xml` 文件对于 Servlet 容器来说是非常重要的配置文件之一。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
        <servlet>
            <!-- 
                <servlet-name> 标签用于定义一个 Servlet 的名称，该名称在 Servlet 容器中必须是唯一的。
                它通常用于配合其他标签，如 <servlet> 和 <servlet-mapping>，来指定一个 Servlet的配置和映			  射关系。 
             -->
            <servlet-name>springMVC</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
            <init-param>
                <!-- contextConfigLocation为固定值,指定 Spring 应用程序上下文配置文件位置的参数 -->
                <param-name>contextConfigLocation</param-name>
                <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的
                src/main/resources -->
                <param-value>/web/WEB-INF/springMVC.xml</param-value>
            </init-param>
            <!--
            作为框架的核心组件，在启动过程中有大量的初始化操作要做
            而这些操作放在第一次请求时才执行会严重影响访问速度
            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
            -->
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>springMVC</servlet-name>
            <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
            -->
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - 创建springmvc.xml文件

    > - 不用手动加载配置文件，在DispatcherServlet初始化的时候就会自动加载SpringMVC的配置文件
    > - 所以SpringMCV配置文件有一个固定的名字和一个固定的位置
    >   - 默认位置：WEB-INF包下
    >   - 默认名称：`<servlet-name>`的值加上`-servlet.xml`，也就是`SpringMVC-servlet.xml`

    - 在 Spring MVC 中，`springmvc.xml`（或其他类似的命名）通常是用来配置 Spring MVC 相关的内容的配置文件，比如【视图解析器】、【拦截器】、【处理器映射】等。它一般放在 `WEB-INF` 目录下，与 `web.xml` 放在同一个目录下或者放在 `WEB-INF/config` 目录下都是比较常见的做法。
    - 通常情况下，`springmvc.xml` 文件的位置会在 `web.xml` 中通过 `<context-param>` 标签来指定

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    
        <!--扫描组件-->
        <context:component-scan base-package="com.cjj.controller"></context:component-scan>
    
        <!-- 配置Thymeleaf视图解析器 -->
        <!--可以使用SpringMVC为我们提供的方式，来进行视图渲染，并实现页面跳转-->
        <!--通过源码：由SpringMVC中DispatcherServlet内部帮我们加载的-->
        <bean id="viewResolver"
              class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
            <!--优先级-->
            <property name="order" value="1"/>
            <!--编码-->
            <property name="characterEncoding" value="UTF-8"/>
            <!--模板引擎-->
            <property name="templateEngine">
                <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                    <!--模板解析器-->
                    <property name="templateResolver">
                        <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
                            <!-- 视图前缀 -->
                            <property name="prefix" value="/WEB-INF/templates/"/>
                            <!-- 视图后缀 -->
                            <property name="suffix" value=".html"/>
                            <property name="templateMode" value="HTML5"/>
                            <property name="characterEncoding" value="UTF-8" />
                        </bean>
                    </property>
                </bean>
            </property>
        </bean>
    </beans>
    ```

- 创建请求控制器

  > 我们SpringMVC封装的是Servlet，我们不需要手动创建servlet，当前所有的请求经过web.xml的配置都被我们的DispatcherServlet来处理了。它处理的是共性的问题：获取请求参数，往域对象中共享数据，页面跳转，转发和重定向。当前请求具体如何处理则需要写一个方法。

  由于`前端控制器`对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即`请求控制器`

  请求控制器中每一个处理请求的方法成为控制器方法

  因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在

  ```java
  // 当前控制层中的方法，可以通过SpringMVC为我们提供的方式将它设置为处理请求的方法
  @Controller
  public class HelloController {
      
  }
  ```

