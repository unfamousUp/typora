# 深入浅出Spring Boot

"约定优于配置"

## 一、Spring Boot来临

### 1.1 Spring的历史

#### - 降低资源耦合

 Spring以强大的控制反转（IOC）来管理各类Java资源，从而==降低了各种资源的耦合==。

> - 降低了各种资源的耦合
>
>   - Java中的资源耦合指的是在代码中资源（如文件、数据库连接、网络连接等）与应用程序的其他部分之间存在紧密的关联关系，`资源的管理和使用与应用逻辑混合在一起`，难以分离和管理。资源耦合通是一种不良的设计实践，因为它会导致代码难以维护、扩展和重用
>
>   - 资源耦合的问题在于，如果不正确管理资源的生命周期，可能会导致资源泄漏或不必要的资源开销，从而影响应用程序的性能和可维护性。通过将资源的管理与应用逻辑分离，可以减少这些问题的发生。

- 一个常见的【数据库连接】的耦合问题：是在代码中直接使用了具体的数据库驱动程序和连接参数，这样会导致代码与特定数据库的耦合，不利于代码的移植和维护。下面是一个简单的示例：

  ```java
  public class DatabaseConnection {
      private static Connection connection;
  
      public static Connection getConnection() {
          if (connection == null) {
              try {
                  Class.forName("com.mysql.jdbc.Driver");
                  connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
              } catch (ClassNotFoundException | SQLException e) {
                  e.printStackTrace();
              }
          }
          return connection;
      }
  }
  ```

  在这个示例中，`DatabaseConnection` 类直接使用了 MySQL 的驱动程序和连接参数，导致了与 MySQL 数据库的耦合。如果要切换到其他数据库，比如 Oracle 或者 PostgreSQL，就需要修改 `DatabaseConnection` 类的代码。

- 解决这个问题的常见方案是使用数据访问层（DAO）模式和配置文件。我们可以定义一个接口来表示数据库连接，然后在配置文件中指定具体的实现类和连接参数。这样，只需要修改配置文件而不需要修改代码就可以切换数据库。下面是一个简单的示例：

  1. 首先，定义一个数据库连接的接口：

  ```java
  public interface DatabaseConnection {
      Connection getConnection();
  }
  ```

  2. 然后，创建两个实现类分别用于连接 MySQL 和 PostgreSQL：

  ```java
  // MySQL连接
  public class MySQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("com.mysql.jdbc.Driver");
              return DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  // PostgreSQL连接
  public class PostgreSQLConnection implements DatabaseConnection {
      @Override
      public Connection getConnection() {
          try {
              Class.forName("org.postgresql.Driver");
              return DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydatabase", "username", "password");
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  
  ```

  3. 最后，在配置文件中指定使用哪个实现类：

  ```java
  <bean id="databaseConnection" class="com.example.MySQLConnection" />
  ```

### 1.2 注解还是XML

- 业务类使用注解，例如MVC开发：控制器使用`@Controller`，业务层使用`service`，持久层使用`@Repository`。
- 对于一些公用的Bean，例如对于数据库（如Redis）、第三方资源等则使用XML进行配置

###  1.3 Spring Boot的优点

- 创建独立的Spring程序

- 嵌入的Tomcat、无需部署WAR文件

- 允许通过Maven来根据需要获取starter

- 尽可能地自动配置Spring

  ....

### 1.4 传统SpringMVC和Spring Boot的对比

#### - Servlet

- Servlet执行流程

  ![image-20220621234937489](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121641694.png)

- Servlet生命周期

  ![image-20220622000339816](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655319.png)

- Servlet体系结构

  ![image-20220622002157646](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403121655200.png)

#### - SpringMVC项目具体流程

##### - xml方式

- 创建空项目-添加maven工程-导入web模块-导入相关依赖

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>com.cjj</groupId>
      <artifactId>springmvc_note</artifactId>
      <version>1.0-SNAPSHOT</version>
      <packaging>war</packaging>
  
      <dependencies>
          <!-- SpringMVC -->
          <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-webmvc</artifactId>
              <version>5.3.1</version>
          </dependency>
          <!-- ServletAPI -->
          <dependency>
              <groupId>javax.servlet</groupId>
              <artifactId>javax.servlet-api</artifactId>
              <version>3.1.0</version>
              <scope>provided</scope>
          </dependency>
          <!-- Spring5和Thymeleaf整合包 -->
          <dependency>
              <groupId>org.thymeleaf</groupId>
              <artifactId>thymeleaf-spring5</artifactId>
              <version>3.0.12.RELEASE</version>
          </dependency>
      </dependencies>
  
  </project>
  
  ```

- 配置web.xml和springmvc.xml

  - 创建web.xml文件

    - `web.xml` 是一个【部署描述符文件】（Deployment Descriptor），用于配置 Servlet 容器（如 Tomcat）在部署和运行应用程序时的行为。`web.xml` 文件中包含了一些重要的配置，如 Servlet、Filter、Listener 等的配置，以及一些全局的配置。

    - 在 Servlet 容器启动时，会由容器来读取并解析 `web.xml` 文件，加载配置的 Servlet、Filter、Listener 等，并按照配置来初始化和处理请求。在 Spring MVC 中，`DispatcherServlet` 会由 Servlet 容器（比如 Tomcat）来创建和管理。

    - `web.xml` 文件由 Servlet 容器（例如 Tomcat、Jetty、JBoss 等）读取和解析。Servlet 容器在启动时会加载部署在其中的 Web 应用程序，并根据 `web.xml` 中的配置初始化 Servlet、Filter、Listener 等，并建立 URL 映射关系，以便处理客户端的请求。

      一旦 Servlet 容器启动并加载了 Web 应用程序，它会负责管理整个应用程序的生命周期，包括请求的路由、Servlet 的生命周期管理、会话管理等。因此，`web.xml` 文件对于 Servlet 容器来说是非常重要的配置文件之一。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
        <servlet>
            <!-- 
                <servlet-name> 标签用于定义一个 Servlet 的名称，该名称在 Servlet 容器中必须是唯一的。
                它通常用于配合其他标签，如 <servlet> 和 <servlet-mapping>，来指定一个 Servlet的配置和映			  射关系。 
             -->
            <servlet-name>springMVC</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
            <init-param>
                <!-- contextConfigLocation为固定值,指定 Spring 应用程序上下文配置文件位置的参数 -->
                <param-name>contextConfigLocation</param-name>
                <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的
                src/main/resources -->
                <param-value>/web/WEB-INF/springMVC.xml</param-value>
            </init-param>
            <!--
            作为框架的核心组件，在启动过程中有大量的初始化操作要做
            而这些操作放在第一次请求时才执行会严重影响访问速度
            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
            -->
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>springMVC</servlet-name>
            <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
            -->
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - 创建springmvc.xml文件

    > - 不用手动加载配置文件，在DispatcherServlet初始化的时候就会自动加载SpringMVC的配置文件
    > - 所以SpringMCV配置文件有一个固定的名字和一个固定的位置
    >   - 默认位置：WEB-INF包下
    >   - 默认名称：`<servlet-name>`的值加上`-servlet.xml`，也就是`SpringMVC-servlet.xml`

    - 在 Spring MVC 中，`springmvc.xml`（或其他类似的命名）通常是用来配置 Spring MVC 相关的内容的配置文件，比如【视图解析器】、【拦截器】、【处理器映射】等。它一般放在 `WEB-INF` 目录下，与 `web.xml` 放在同一个目录下或者放在 `WEB-INF/config` 目录下都是比较常见的做法。
    - 通常情况下，`springmvc.xml` 文件的位置会在 `web.xml` 中通过 `<context-param>` 标签来指定

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    
        <!--扫描组件-->
        <context:component-scan base-package="com.cjj.controller"></context:component-scan>
    
        <!-- 配置Thymeleaf视图解析器 -->
        <!--可以使用SpringMVC为我们提供的方式，来进行视图渲染，并实现页面跳转-->
        <!--通过源码：由SpringMVC中DispatcherServlet内部帮我们加载的-->
        <bean id="viewResolver"
              class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
            <!--优先级-->
            <property name="order" value="1"/>
            <!--编码-->
            <property name="characterEncoding" value="UTF-8"/>
            <!--模板引擎-->
            <property name="templateEngine">
                <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                    <!--模板解析器-->
                    <property name="templateResolver">
                        <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
                            <!-- 视图前缀 -->
                            <property name="prefix" value="/WEB-INF/templates/"/>
                            <!-- 视图后缀 -->
                            <property name="suffix" value=".html"/>
                            <property name="templateMode" value="HTML5"/>
                            <property name="characterEncoding" value="UTF-8" />
                        </bean>
                    </property>
                </bean>
            </property>
        </bean>
    </beans>
    ```

- 创建请求控制器

  > 我们SpringMVC封装的是Servlet，我们不需要手动创建servlet，当前所有的请求经过web.xml的配置都被我们的DispatcherServlet来处理了。它处理的是共性的问题：获取请求参数，往域对象中共享数据，页面跳转，转发和重定向。当前请求具体如何处理则需要写一个方法。

  由于`前端控制器`对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即`请求控制器`

  请求控制器中每一个处理请求的方法成为控制器方法

  因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在

  ```java
  // 当前控制层中的方法，可以通过SpringMVC为我们提供的方式将它设置为处理请求的方法
  @Controller
  public class HelloController {
      
  }
  ```

##### - 注解方式

- 创建初始化类`【WebInit】`，代替web.xml

  > - Servlet容器：Tomcat
  >
  > - 在Servlet3.0环境中，容器会在类路径中查找实现`javax.servlet.ServletContainerInitializer`接口的实现类，如果找到的话就用它来配置Servlet容器。
  >
  >   Spring提供了这个接口的实现，名为`SpringServletContainerInitializer`，这个类反过来又会查找实现`WebApplicationInitializer`的类并将配置的任务交给它们来完成。
  >
  >   Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为`AbstractAnnotationConfigDispatcherServletInitializer`，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。

  ```java
  package com.cjj.config;
  import org.springframework.web.filter.CharacterEncodingFilter;
  import org.springframework.web.filter.HiddenHttpMethodFilter;
  import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
  
  import javax.servlet.Filter;
  //【WebInit】
  // web.xml
  // WebInit拓展了Spring实现的Servlet容器初始化器，这样我们自定义的类就可以被Tomcat容器找到了
  public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {
  	
      // 配置1
      @Override
      protected Class<?>[] getRootConfigClasses() {
          return new Class[]{SpringConfig.class};
      }
  
      // SpringMVC配置类
      @Override
      protected Class<?>[] getServletConfigClasses() {
          return new Class[]{WebConfig.class};
      }
  	
      // 设置DispatcherServlet 的映射路径
      @Override
      protected String[] getServletMappings() {
          return new String[]{"/"};
      }
  
      @Override
      // 设置当前的过滤器
      protected Filter[] getServletFilters() {
          // 创建编码过滤器
          CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
          // 设置请求和响应的编码
          characterEncodingFilter.setEncoding("UTF-8");
          characterEncodingFilter.setForceEncoding(true);
          // 创建请求方式的过滤器
          HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
          return new Filter[]{characterEncodingFilter,hiddenHttpMethodFilter};
      }
  }
  ```

- 创建WebConfig配置类，代替SpringMVC的配置文件

  > SpringMVC配置过的内容
  >
  > 1. 扫描控制层组件
  > 2. 视图解析器
  > 3. view-controller默认的servlet处理静态资源
  > 4. 开启mvc注解驱动
  > 5. 文件上传解析器
  > 6. 拦截器
  > 7. 异常解析器

```java
/**
 * 代替SpringMVC的配置文件
 */
// 将类表示为配置类
@Configuration
// 扫描组件
@ComponentScan("com.cjj.controller")
// 开启MVC注解驱动
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    // 默认的servlet处理静态资源
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
        WebMvcConfigurer.super.configureDefaultServletHandling(configurer);
    }

    @Override
    // 配置视图解析器
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
        WebMvcConfigurer.super.addViewControllers(registry);
    }

    @Bean
    // 文件上传解析器：被Bean标识的方法的返回值将会作为bean被IOC容器所管理,bean的id为方法名
    public CommonsMultipartResolver multipartResolver() {
        return new CommonsMultipartResolver();
    }

    @Override
    // 配置拦截器
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");
        WebMvcConfigurer.super.addInterceptors(registry);
    }

    @Override
    // 异常处理器
    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
        properties.setProperty("java.lang.ArithmeticException", "error");
        exceptionResolver.setExceptionMappings(properties);
        exceptionResolver.setExceptionAttribute("ex");
        resolvers.add(exceptionResolver);
        WebMvcConfigurer.super.configureHandlerExceptionResolvers(resolvers);
    }

    //配置生成模板解析器
    @Bean
    public ITemplateResolver templateResolver() {
        WebApplicationContext webApplicationContext =
                ContextLoader.getCurrentWebApplicationContext();
        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，
        // 可通过WebApplicationContext的方法获得
        ServletContextTemplateResolver templateResolver =
                new ServletContextTemplateResolver(webApplicationContext.getServletContext());
        templateResolver.setPrefix("/WEB-INF/templates/");
        templateResolver.setSuffix(".html");
        templateResolver.setCharacterEncoding("UTF-8");
        templateResolver.setTemplateMode(TemplateMode.HTML);
        return templateResolver;
    }

    //生成模板引擎并为模板引擎注入模板解析器
    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
    }

    //生成视图解析器并为解析器注入模板引擎
    @Bean
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setCharacterEncoding("UTF-8");
        viewResolver.setTemplateEngine(templateEngine);
        return viewResolver;
    }

}
```

- 拦截器的配置

```java
@Component
public class FirstInterceptor implements HandlerInterceptor {
    /**
     * 控制器方法执行之前执行
     * @param request
     * @param response
     * @param handler
     * @return false:拦截|true:放行
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("FirstInterceptor-->preHandle");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("FirstInterceptor-->postHandle");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("FirstInterceptor-->afterCompletion");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

```java
// springMVC.xml
@Configuration
@EnableWebMvc
@ComponentScan("com.cjj.controller")
public class WebConfig implements WebMvcConfigurer {

    @Override
    // 配置拦截器
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");
        WebMvcConfigurer.super.addInterceptors(registry);
    }
    
}
```

## 二、开发环境（略）

## 三、全注解下的Spring IOC

IOC是一种通过`描述`来生成或者获取对象的技术。

> - Spring Bean（Bean）：在Spring中需要管理的每一个对象
> - Spring IOC容器（IOC 容器）：由Spring管理这些Bean的容器
>   - 通过描述管理Bean，包括发布和获取Bean
>   - 通过描述来完成Bean之间的依赖关系

### 3.1 IOC容器简介

#### 3.1.1 BeanFactory

所有IOC容器都需要实现接口`BeanFactory`，它是一个顶级容器接口。

> 注意：
>
> - IOC容器中，默认Bean都是以单例存在的，也就是使用`getBean`方法返回的都是同一个对象！反之，如果`isPrototype`方法返回的是`true`，那使用`getBean`方法获取bean时，IOC容器就会创建一个新的Bean给调用者。
>
> - 由于BeanFactory功能还不够强大，于是设计了一个更高级的子接口`ApplicationContext`。
>
>   ![image-20240313163418400](https://gitee.com/chen-jiujia/typora-picgo/raw/master/img/202403131634567.png)

```java
public interface BeanFactory {
    String FACTORY_BEAN_PREFIX = "&";

    // 多个getBean方法
    Object getBean(String var1) throws BeansException;

    <T> T getBean(String var1, Class<T> var2) throws BeansException;

    Object getBean(String var1, Object... var2) throws BeansException;

    <T> T getBean(Class<T> var1) throws BeansException;

    <T> T getBean(Class<T> var1, Object... var2) throws BeansException;

    <T> ObjectProvider<T> getBeanProvider(Class<T> var1);

    <T> ObjectProvider<T> getBeanProvider(ResolvableType var1);

    // 是否包含Bean
    boolean containsBean(String var1);

    // Bean是否是单例
    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;

    // Bean是否是原型
    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;

    // Bean是否类型匹配
    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, Class<?> var2) throws NoSuchBeanDefinitionException;

    // 获取Bean的类型
    @Nullable
    Class<?> getType(String var1) throws NoSuchBeanDefinitionException;

    @Nullable
    Class<?> getType(String var1, boolean var2) throws NoSuchBeanDefinitionException;

    // 获取Bean的别名
    String[] getAliases(String var1);
}
```

#### 3.1.2 代码实现

> 定义一个java配置文件AppConfig
>
> - Spring 管理的 IOC 容器
>   - `SpringApplication.run(MyApplication.class, args)` 方法会创建一个 IOC 容器，并扫描应用程序中的所有 `@Component`、`@Service`、`@Repository` 和 `@Controller` 注解标记的类，并将它们注册为 bean。这个 IOC 容器就是 Spring 管理的 IOC 容器，负责管理整个应用程序的 bean。
>
> - 手动创建的IOC容器
>
>   `AnnotationConfigApplicationContext` 是 Spring Framework 提供的一个用于基于注解配置的应用程序上下文实现类。它允许你使用 Java 类作为配置类，通过注解来声明 Spring bean，而不需要使用传统的 XML 配置文件。
>
>   在 Spring 中，ApplicationContext 是一个接口，用于表示 Spring 容器。它代表了 Spring 应用程序的整个上下文，包括了所有的` bean 定义、bean 的配置以及这些 bean 之间的依赖关系`。
>
>   为什么叫做应用程序上下文呢？这是因为 ApplicationContext 中包含了当前应用程序运行时的所有信息，它提供了一个环境，让各个组件可以共享和访问这些信息。这个“上下文”可以理解为一个容器，它包含了应用程序运行时所需的所有资源和对象，可以帮助开发人员更方便地管理和访问这些资源和对象。
>
>   ```java
>       // 创建一个新的IOC容器，并将AppConfig本身作为bean以及AppConfig 类中定义的 bean 注册到了这个容器中。
>       ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);
>   ```

```java
@Configuration
public class AppConfig {
    @Bean("user")
    public User initUser(){
        User user = new User();
        user.setAge(19);
        user.setName("cjj");
        return user;
    }
}
```

> IOCTest测试方法

```java
@Test
void IOCTest(){
    // 创建一个新的IOC容器，并将AppConfig本身作为bean以及AppConfig 类中定义的 bean 注册到了这个容器中。
    ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);
    User user = ioc.getBean(User.class);
    System.out.println(user);
}
```

#### 3.1.3 注意

@Bean注解如果没指定bean的名称，那么默认会使用方法名作为bean的名称保存到IOC容器中

### 3.2 装配你的Bean

#### 3.2.1 通过扫描装配你的Bean

如果使用`@Bean`注解一个个把Bean注入到IOC容器中，很麻烦。可以使用`@Component`和@`ComponentScan`注解。

> - `@Component("bean名称")`
>   - beanName：作为bean的名称，不配IOC容器默认把类名的第一个字母小写作为bean的名称。
> - `@Value("属性值")`
>   - 指定属性的值，IOC容器会自动注入。

```java
@Component("user")
public class User {

    @Value("cjj")
    private String name;

    @Value("18")
    private Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
```

> 为了能让IOC容器装配这个被注解标识的类，还得改造AppConfig配置类
>
> - `@ComponentScan`
>   - 默认扫描当前类所在包和其子包下的组件

```java
@Configuration
@ComponentScan("com.cjj.pojo")
public class AppConfig {
    
}
```

##### 3.2.1.1 @ComponentScan

> `public @interface ComponentScan`

```java
// 设置注解在运行时可见
@Retention(RetentionPolicy.RUNTIME)
// 指定注解可以应用的目标元素类型为类
@Target({ElementType.TYPE})
// 生成 Javadoc 时包含注解信息
@Documented
// 在一个类中可重复定义
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
    // value 和 basePackages 为别名关系，使用其中一个时，另一个会自动使用相同的值
    @AliasFor("basePackages")
    String[] value() default {};

    @AliasFor("value")
    String[] basePackages() default {};

    // 指定要扫描的基础包类
    Class<?>[] basePackageClasses() default {};

    // 指定生成 bean 名称的策略类，默认为 BeanNameGenerator.class
    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

    // 指定解析作用域的策略类，默认为 AnnotationScopeMetadataResolver.class
    Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

    // 指定作用域代理模式，默认为 ScopedProxyMode.DEFAULT
    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

    // 指定要扫描的资源模式，默认为 "**/*.class"
    String resourcePattern() default "**/*.class";

    // 是否使用默认过滤器，默认为 true
    boolean useDefaultFilters() default true;

    // 当满足滤器条件时扫描
    ComponentScan.Filter[] includeFilters() default {};

    // 当不满足滤器条件时扫描
    ComponentScan.Filter[] excludeFilters() default {};

    // 是否延迟初始化，默认为 false
    boolean lazyInit() default false;

    // 定义内部的 Filter 注解，用于指定过滤器规则
    @Retention(RetentionPolicy.RUNTIME)
    @Target({})
    public @interface Filter {
        // 过滤器类型，默认为 FilterType.ANNOTATION 注解类型
        FilterType type() default FilterType.ANNOTATION;

        // 别名为 value 的 classes 属性
        @AliasFor("classes")
        Class<?>[] value() default {};

        @AliasFor("value")
        Class<?>[] classes() default {};

        // 过滤器规则的正则表达式模式
        String[] pattern() default {};
    }
}
```

例：排除UserService.class类

> `@ComponentScan`的`excludeFilters`属性要求传`ComponentScan.Filter[]`注解类型的数组。`@ComponentScan.Filter`注解的`type`属性默认为`FilterType.ANNOTATION`注解类型。
>
> 所以要过滤一个【类类型】的组件，则需要重新指定`type = FilterType.ASSIGNABLE_TYPE`。

```java
@Configuration
@ComponentScan(basePackages = {"com.cjj"},excludeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = UserService.class)})
public class AppConfig {

}
```

##### 3.2.1.2 @SpringBootApplication

> - `FilterType.CUSTOM` 是 Spring 框架中 `@ComponentScan` 注解的一个过滤类型，它允许开发者定义自定义的组件扫描规则。当 Spring 容器在启动时进行组件扫描时，`FilterType.CUSTOM` 允许你通过实现 `TypeFilter` 接口来定义哪些类应该被包含或排除在组件扫描的结果中。
>
> - 使用 `FilterType.CUSTOM` 时，你需要创建一个类，该类实现了 `TypeFilter` 接口，并覆盖其 `match` 方法。`match` 方法接收两个参数：`MetadataReader` 和 `MetadataReaderFactory`，你可以利用这两个参数来执行自定义的匹配逻辑。
>
> - 在下面的源码中，`@ComponentScan` 注解使用了 `excludeFilters` 属性来定义要排除的组件。`excludeFilters` 允许你指定一组过滤器，这些过滤器决定了哪些组件不应该被 Spring 容器发现并注册为 beans。
>
>   下述使用了两个自定义的 `TypeFilter`：`TypeExcludeFilter` 和 `AutoConfigurationExcludeFilter`。每个 `Filter` 的 `type` 属性都被设置为 `FilterType.CUSTOM`，表明这是一个自定义的过滤规则。
>
>   `classes` 属性指定了实现 `TypeFilter` 接口的类，这些类定义了排除规则的具体实现。
>
>   - `TypeExcludeFilter.class` 应该是一个实现了 `TypeFilter` 接口的类，它的 `match` 方法将定义哪些类应该被排除。例如，它可以检查类的注解、名称或其他属性来决定是否排除。
>   - `AutoConfigurationExcludeFilter.class` 同样是一个自定义的 `TypeFilter` 实现，它可能用于排除自动配置类，或者基于其他特定的条件来排除组件。
>
>   当 Spring 容器执行组件扫描时，它会应用这些排除过滤器。任何匹配 `TypeExcludeFilter` 或 `AutoConfigurationExcludeFilter` 的组件都将不会被注册为 Spring 容器管理的 beans。
>
>   这种机制非常有用，特别是当你想要更精细地控制哪些类应该被 Spring 容器管理时。例如，在大型项目中，你可能想要排除一些测试类、配置类或其他你不希望在生产环境中加载的类。通过自定义 `TypeFilter` 并将其与 `@ComponentScan` 的 `excludeFilters` 属性结合使用，你可以实现这种控制。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class} // 
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class} // 
)}
)
public @interface SpringBootApplication {
    // Spring中@AliasFor注解的作用主要是将一个注解上的属性值传递给另一个注解或者将同一个注解类的属性设置互为别名.
    @AliasFor(
        annotation = EnableAutoConfiguration.class
    )
    Class<?>[] exclude() default {};

    @AliasFor(
        annotation = EnableAutoConfiguration.class
    )
    String[] excludeName() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = "basePackages"
    )
    String[] scanBasePackages() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = "basePackageClasses"
    )
    Class<?>[] scanBasePackageClasses() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = "nameGenerator"
    )
    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

    @AliasFor(
        annotation = Configuration.class
    )
    boolean proxyBeanMethods() default true;
}
```

##### 3.2.1.3 注解的元数据、元注解的元数据

1. 注解的元数据

> 注解的元数据（Metadata）是关于注解的数据，它描述了注解的属性、值以及其他相关信息。在Java和其他编程语言中，注解本身是一种特殊的标记，用于为代码提供额外的信息，这些信息可以在【编译时或运行时】被处理。而注解的元数据则是关于这些注解的额外描述，【它帮助框架或工具理解注解的意图和用途】。
>
> 例如，在Spring Boot中，`@SpringBootApplication`是一个常见的注解，它包含了多个元注解，如`@EnableAutoConfiguration`、`@ComponentScan`等。这些元注解的元数据描述了它们各自的作用和配置。当Spring Boot容器启动时，它会读取这些注解的元数据，并根据这些元数据来配置应用程序。
>
> `元数据`通常包括注解的名称、类型、所应用的元素（如类、方法、字段等）、以及注解的参数值等信息。这些信息对于处理注解的框架或工具来说是至关重要的，因为它们需要这些元数据来正确地解释和应用注解。
>
> 在编程实践中，通过查看注解的元数据，开发者可以更好地理解注解的用途和配置方式，从而更有效地使用注解来简化代码和提高开发效率。同时，框架和工具的设计者也可以利用注解的元数据来提供更为灵活和强大的功能。

2. 元注解的元数据

> 元注解的元数据指的是描述元注解本身的数据，它包括了元注解的定义、类型、属性、属性值以及其他与元注解相关的信息。元数据是关于数据的数据，具体到元注解的情境下，它提供了关于元注解如何工作、应用于哪些目标、生命周期如何等的信息。
>
> 在Java中，元注解是用来定义其他注解的注解。Java提供了几种元注解，如`@Target`、`@Retention`、`@Documented`、`@Inherited`等。这些元注解用于指定自定义注解的行为和特性。
>
> - `@Target`：它定义了注解的作用目标，例如类、方法、字段等。其属性值是一个枚举类型，指定了注解可以应用的Java元素类型。
> - `@Retention`：它定义了注解的生命周期，即注解在何时有效。其属性值有三个：`SOURCE`（只在源码中存在，编译时被丢弃）、`CLASS`（编译时被记录在class文件中，但JVM加载时不保留）、`RUNTIME`（编译时被记录在class文件中，且JVM加载时保留，因此运行时可以通过反射访问）。
>
> 这些元注解的属性值就是其元数据的一部分，它们定义了元注解的具体行为。当开发者定义一个自定义注解时，他们会使用这些元注解及其属性值来指定自定义注解的特性和行为。
>
> 例如，如果开发者想要创建一个只能在方法上使用的注解，并且这个注解在运行时仍然有效，那么他们可能会这样定义：
>
> ```java
> @Target(ElementType.METHOD)  
> @Retention(RetentionPolicy.RUNTIME)  
> public @interface MyCustomAnnotation {  
>     // ... 注解的属性定义 ...  
> }
> ```
>
> 在这个例子中，`@Target(ElementType.METHOD)`和`@Retention(RetentionPolicy.RUNTIME)`就是元注解，而`ElementType.METHOD`和`RetentionPolicy.RUNTIME`则是这些元注解的属性值，它们共同构成了元注解的元数据。

3. 总结

当一个类被注解标识，在运行时可以使用反射机制动态的获取类上的注解信息，然后读取这些注解的元数据，包括标识注解的注解（元注解），并根据这些元数据来配置应用程序。然后会遍历其注解的属性值，判断其身上有没有被其它注解标识，从而进一步配置应用程序。